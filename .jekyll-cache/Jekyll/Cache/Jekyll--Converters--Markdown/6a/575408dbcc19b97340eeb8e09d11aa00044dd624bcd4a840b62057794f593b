I"#<p>데이터 베이스 시험을 대비하여서 처음부터 정리를 하고 있다. 지금은 두번째 정리이다.</p>

<!--more-->

<h1 id="database1">DataBase(1)</h1>
<h2 id="데이터베이스-스키마시스템-카탈로그-데이터-사전">데이터베이스 스키마=시스템 카탈로그, 데이터 사전</h2>

<ul>
  <li>전체적인 데이터베이스 구조를 뜻함 “<em>틀</em>”</li>
  <li>자주 변경되지는 않음</li>
  <li>내포(intension)라고 부름</li>
</ul>

<h2 id="데이터베이스-상태">데이터베이스 상태</h2>

<ul>
  <li>특정 시점의 데이터베이스의 _내용_을 의미함</li>
  <li>시간이 지남에 따라 계속해서 바뀜</li>
  <li>외연(extension)이라고 부름</li>
</ul>

<h2 id="데이터베이스-시스템dbs-database-system의-구성-요소">데이터베이스 시스템(DBS: Database System)의 구성 요소</h2>

<ul>
  <li>데이터베이스, DBMS, 사용자, 하드웨어</li>
  <li>데이터베이스 시스템 의미: 4개의 구성요소가 잘 협력하여 방대한 양의 데이터를 잘 관리하는 총제적인 기술</li>
</ul>

<h3 id="데이터베이스">데이터베이스</h3>

<ul>
  <li>조직체의 응용 시스템들이 공유해서 사용하는 운영 데이터들이 구조적으로 통합된 모임</li>
  <li>시스템 카탈로그(또는 데이터 사전)와 저장된 데이터베이스로 구분할 수 있음</li>
  <li>시스템 카탈로그(system catalog)는 저장된 데이터베이스의 스키마 정보를 유지</li>
</ul>

<h3 id="dbms">DBMS</h3>

<ul>
  <li>사용자가 데이터베이스를 생성, <code class="highlighter-rouge">데이터베이스의 구조를 &lt;u&gt;명시&lt;/u&gt;</code>할 수 있게 하고, 사용자가 데이터를 효율적으로 질의하고 수정할 수 있도록 하며, 시스템의 고장이나 권한이 없는 사용자로부터 데이터를 안전하게 보호하며, 동시에 여러 사용자가 데이터베이스를 접근하는 것을 제어하는 <em>소프트웨어 패키지</em></li>
  <li>데이터베이스 언어라고 부르는 특별한 프로그래밍 언어를 한 개 이상 제공(p.40)</li>
  <li>SQL은 여러 DBMS에서 제공되는 사실 상의 표준 데이터 베이스 언어</li>
</ul>

<h3 id="사용자">사용자</h3>

<ul>
  <li>데이터베이스 사용자는 여러 부류로 나눌 수 있음</li>
  <li>p.43</li>
</ul>

<h3 id="하드웨어">하드웨어</h3>

<ul>
  <li>데이터베이스는 디스크와 같은 <u>보조 기억 장치</u>에 저장되며, DBMS에서 원하는 정보를 찾기 위해서는 디스크의 블록들을 주기억 장치로 읽어들여야 하며, 계산이나 비교 연산들을 수행하기 위해 중앙 처리 장치가 사용됨</li>
  <li>DBMS 자체도 주기억 장치에 적재되어 실행되어야 함.</li>
</ul>

<h4 id="용어-정리">용어 정리</h4>

<p>| 공식적인 용어 | 자주 사용되는 용어 | 화일 시스템의 용어 |
| ————- | —————— | —————— |
| 릴레이션      | 테이블             | 화일               |
| 투플, 카디날리티          | 행/레코드          | 레코드             |
| 애트리뷰트, 차수    | 열, 속성, 컬럼     | 필드               |
<img src="/assets/images/posts/DB-01/table.png" class="img-responsive" /></p>

<h2 id="데이터-모델">데이터 모델</h2>

<p>데이터베이스의 구조를 기술하는데 사용되는 개념들의 집합인 <strong>구조</strong>(데이터 타입과 관계), 이 구조 위에서 동작하는 <strong>연산</strong>자들, 무결성 <strong>제약 조건</strong>들로 이루어짐</p>

<p>데이터 모델을 보고 그 데이터베이스가 어떻게 생겼는지(<strong>구조(structure)</strong>), 그 데이터베이스는 어떤 기능을 담당하는지(<strong>연산(operation)</strong>),  그 데이터베이스가 오류가 없도록 지켜져야 하는 규칙들은 뭐가 있는지(<strong>무결성 제약 조건(constraints)</strong>), 이런 세가지 조건이 데이터 모델 안에 담겨져 있다.</p>

<p>DM := &lt;Structure, Operation, Constraints&gt;</p>

<p>=&gt; 이론적 데이터 모델을 SW로 구현한 것이 바로DBMS이다.
<img src="/assets/images/posts/DB-01/soc.png" class="img-responsive" /></p>
<h2 id="관계-데이터-모델">관계 데이터 모델</h2>

<blockquote>
  <p>릴레이션의 관점에서 모든 데이터를 <code class="highlighter-rouge">논리적으로 구성</code>하며 <code class="highlighter-rouge">선언적인 질의어(원하는 데이터what만 명시, 어떻게 찾는 지how는 명시 X)를 통한 데이터 접근을 제공</code>한다.
 한 릴레이션은 데이터베이스에 표현되는 <code class="highlighter-rouge">한 엔티티(하나의 주제만 들어가야한다.)</code>에 관한 정보를 저장한다.
릴레이션의 각 행을 <code class="highlighter-rouge">레코드(=튜플)</code>라고 부른다.
릴레이션의 하나의 열을 <code class="highlighter-rouge">애트리뷰트</code>라고 부른다. 애트리뷰트는 서로 이름이 달라야하고 적당한 의미를 갖고 있어야한다.</p>

  <p>차수(degree): 열들의 개수(최소 1개)
카디날리티(cardinality): 행들의 개수(=튜플의 개수)
도메인: 한 애트리뷰트에 나타날 수 있는 값들의 집합(=데이터 타입)이다. 각 애트리뷰트의 도메인의 값들은 원잣값이다.</p>
</blockquote>

<h3 id="릴레이션의-특성">릴레이션의 특성</h3>

<blockquote>
  <p>관계 데이터 모델에서 릴레이션은 투플들의 집합이다.</p>
</blockquote>

<ul>
  <li>
    <p>각 릴레이션은 오직 하나의 레코드 타입만 포함한다.</p>
  </li>
  <li>한 애트리뷰트 내의 값들은 모두 같은 유형이다.</li>
  <li>각 애트리뷰트의 이름은 한 릴레이션 내에서만 고유하다.</li>
</ul>

<p>ㄹㅇ 4대 특징</p>

<ol>
  <li>애트리뷰트들의 순서는 중요하지 않다. (애트리뷰트의 무순서) 이유는 애트리뷰트는 집합이기 때문에 집합의 원리가 적용된다.</li>
  <li>릴레이션이 투플들의 집합이기 때문에 동일한 투플이 두 개 이상 존재하지 않는다. (투플의 유일성)</li>
  <li>한 투플의 각 애트리뷰트는 원잣값을 갖는다. (애트리뷰트의 원잣값)</li>
  <li>릴레이션이 투플들의 집합이기 때문에 투플들의 순서는 중요하지 않다.
    <h3 id="릴레이션-키">릴레이션 키</h3>
    <blockquote>
      <p>키는 애트리뷰트들의 모임이다.</p>
    </blockquote>
  </li>
</ol>

<h4 id="역할">역할</h4>

<ol>
  <li>특정 투플을 검색</li>
  <li>다른 투플들과 연관시킬 수 있도록하기위해서</li>
</ol>

<p>키를 구성하는 애트리뷰트 수가 적을수록 좋다.
키가 작을수록 인덱스의 크기가 줄어들고 인덱스를 검색하는 시간이 단축된다.</p>

<h4 id="종류">종류</h4>

<ul>
  <li>수퍼 키(super key)</li>
</ul>

<blockquote>
  <p>한 릴레이션 내의 특정 투플을 고유하게 식별하는 하나 이상의 애트리뷰트의 모임이다.</p>
</blockquote>

<ul>
  <li>후보 키(candidate key)</li>
</ul>

<blockquote>
  <p>각 투플을 고유하게 식별(슈퍼키의 속성)하는 최소한의 애트리뷰트들의 모임 (유일성 + 최소성)</p>

  <p>후보 키도 두 개 이상의 애트리뷰트로 이루어질 수 있으며 이 경우에 <strong>복합키</strong>라고 부른다.</p>

  <p>어떤 시점에 중복된 값이 없다고 해서 미래에도 중복이  발생하지 않는다고 단정할 수는 없다.</p>
</blockquote>

<ul>
  <li>기본 키(primary key)</li>
</ul>

<blockquote>
  <p>후보 키가 두 개 이상 있으면 데이터베이스 설계자 도는 데이터베이스 관리자가 이들 중에서 하나를 기본 키로 선정한다.</p>

  <p>자연스러운 기본 키를 찾을 수 없는 경우에는 레코드 번호와 같이 종종 인위적인 키 애트리뷰트를 릴레이션에 추가할 수 있다. 이를 대리 키(surrogate key), 인공 키라고 한다.</p>

  <p>고려사항</p>

  <ul>
    <li>애트리뷰트가 항상 고유한 값을 가질 것인가</li>
    <li>애트리뷰트가 확실하게 널값을 갖지 않을 것인가</li>
    <li>애트리뷰트의 값이 변경될 가능성이 높은 애트리뷰트는 기본 키로 선정하지 말 것</li>
    <li>가능하면 작은 정수 값이나 짧은 문자열을 갖는 애트리뷰트</li>
    <li>가능하면 복합 기본 키를 피할 것</li>
  </ul>
</blockquote>

<ul>
  <li>대체 키</li>
</ul>

<blockquote>
  <p>기본 키로 선정되지 않은 후보 키</p>
</blockquote>

<ul>
  <li>외래 키(foreign key)</li>
</ul>

<blockquote>
  <p>어떤 릴레이션의 기본 키를 참조하는 애트리뷰트이다.
릴레이션들 간의 관계를 나타내기 위해서 사용
외래 키 애트리뷰트는 참조되는 릴레이션의 기본 키와 동일한 도메인을 가져야 한다.</p>
</blockquote>
:ET